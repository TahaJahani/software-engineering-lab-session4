# software-engineering-lab-session4

| `Person Number` | `First Name`  |  `Last Name`  | `Student Number` |
  |:-------------:|:-------------:|:----------------:|:----------------:|
| `First Person` |     Iman      |    Alipour    |     98102024     |
| `Second Person` | Moahmmad Taha | Jahani-Nezhad |     98101363     |
---
## بخش اول
طبق دستورکار داده شده، ابتدا باید نرم افزار Yourkit را دانلود و نصب کنیم.

برای انجام این کار، به وبسایت سازنده‌ی نرم افزار مراجعه می‌کنیم. از آنجایی که ما از آخرین ورژن نرم افزار IntelliJ استفاده می‌کنیم، آخرین نسخه‌ی این نرم افزار را دانلود می‌کنیم تا در نصب و اجرا با مشکل تطابق نسخه روبرو نشویم.

پس از دانلود نرم افزار و اجرای مراحل نصب از روی وبسایت، نرم افزار به طور کامل نصب می‌شود. تصویر زیر محیط این نرم افزار را پس از اولین اجرا نمایش می‌دهد:
![محیط اولیه نرم افزا](./images/01%20-%20Install%20Yourkit.png)
اکنون باید این نرم افزار را به IntelliJ متصل و Integrate کنیم.
<br>
برای انجام این کار گزینه‌ی _Profile With IDE..._ را از منوی اصلی برنامه انتخاب می‌کنیم و از لیست نرم‌افزارهای پیشنهادی، IntelliJ را انتخاب می‌کنیم.
<br>
اکنون برای اینکه مطمئن شویم Yourkit به درستی با IntelliJ هماهنگ شده است، وارد بخش _Plugins_ در نرم افزار IntelliJ می‌شویم و مشاهده می‌کنیم که در بخش _Installed Plugins_ نام Yourkit دیده می‌شود:
![پلاگین‌ها در اینتلیجی](./images/02%20-%20Integrate%20With%20IntelliJ.png)
در ادامه، باید پروژه‌ی داده شده را کلون کرده و اجرا کنیم و با استفاده از Yourkit میزان مصرف منابع آن‌را رصد کنیم.
<br>
ابتدا برای اطمینان از صحت نصب وابستگی‌ها و نبود مشکلی در کد، آن‌را کامپایل می‌کنیم. در تصویر زیر نتیجه‌ی کامپایل کد نمایش داده شده است. همانطور که مشاهده می‌شود، کد بدون هیچ خطایی کامپایل می‌شود.
![نتیجه‌ی کامپایل کد](./images/03%20-%20Compile%20Project.png)
اکنون باید پروژه را اجرا کنیم. اما برای اینکه بتوانیم با استفاده از Yourkit عمل Profiling را انجام دهیم، باید به نحو خاصی کد اجرا شود.

<p style="align-items: center; display: flex;" dir="rtl">
به همین علت، کد را با استفاده از دکمه‌ی
<img src="./images/Run%20With%20Profiler.png"  width="30px" height="30px" style="margin-left: 8px; margin-right: 8px">
اجرا می‌کنیم. 
</p>

پس از اجرا و دادن وروی‌های مورد نیاز کد، نتیجه به صورت زیر نمایش داده می‌شود:
![اجرای کد](./images/06%20-%20Run%20Project.png)
پس از آنکه اجرای کد با موفقیت به پایان رسید، دوباره پنجره‌ی خود نرم افزار Yourkit را باز می‌کنیم تا نمودارها و اطلاعات مربوط به Profiling را مشاهده کنیم.
<br>
ابتدا میزان مصرف CPU را بررسی می‌کنیم:
![مصرف CPU](./images/07%20-%20Cpu%20Usage.png)
همانطور که در تصویر مشاهده می‌شود، کل اجرای برنامه حدود ۵۰ ثانیه طول کشیده است که این بازه شامل مدت زمانی که کاربر مشغول وارد کردن ورودی‌های مورد نیاز برنامه بوده است، نیز می‌باشد.
در نمودار، حدود ۲۰ ثانیه‌ی اول هیچ مصرف CPUیی مشاهده نمی‌شود. احتمالا این مدت زمان همان بازه‌ای است که کاربر مشغول وارد کردن ورودی‌ها بوده است. پس از آن، مصرف CPU افزایش قابل توجهی دارد که یعنی اجرای اصلی برنامه شروع شده و محاسبات در این بازه انجام می‌شوند.
<br>
در نمودار دیگر، تعداد تردهای استفاده شده در CPU برای اجرای این برنامه نوشته شده است. توجه کنید که در کد خود برنامه تنها از یک ترد استفاده شده ولی CPU برای اجرای این برنامه از طریق IntelliJ و همچنین انجام همزمان Profiling به تعداد تردهای بیشتری نیاز داشته است و بنابراین در تمام طول برنامه از حدود ۷ ترد استفاده شده است.

اکنون نمودار دیگری را بررسی می‌کنیم. در تصویر زیر اطلاعات مربوط به مصرف منابع برای تردهای مختلف برنامه نمایش داده شده است:
![اطلاعات تردها](./images/08%20-%20Threads.png)
چونکه ما در این برنامه تنها یک ترد داشته‌ایم، اطلاعات زیادی از این بخش به دست نمی‌آید. اما به طور کلی در اینجا مدت زمانی که اجرای هر ترد طول کشیده نمایش داده می‌شود و با استفاده از این بخش می‌توان تردهایی که روند اجرای برنامه را کند می‌کنند ردیابی و در صورت نیاز بهینه‌سازی کرد.

در تصویر بعدی، _Call Tree_ برنامه نمایش داده شده است:
![Call Tree](./images/09%20-%20Call%20Tree.png)
در این بخش، مدت زمان اجرای هر تابع به ترتیب زمان صدا زده شدن نوشته شده است.
همانطور که انتظار می‌رفت، ۱۰۰ درصد زمان برنامه در تابع `main` بوده و دیگر توابع نیز هرکدام درصدی از زمان کل اجرا را پر کرده‌اند.

بخش دیگری مشابه این بخش وجود دارد که در آن _Method List_ نمایش داده شده است:
![Method List](./images/10%20-%20Method%20List.png)
این لیست تقریبا همان اطلاعات بخش قبلی را نمایش می‌دهد. بنابراین توضیح اضافه‌تری برای این لیست ارائه نمی‌کنیم.

اکنون وارد یک Tab دیگر در برنامه می‌شویم. در تب _Memory_ اطلاعات مربوط به مصرف منابع حافظه نمایش داده شده‌اند:
![مصرف حافظه](./images/11%20-%20Memory%20Usage.png)
در نمودار اول، میزان مصرف حافظه‌ی Heap نمایش داده شده است. در حدود ۱۵ ثانیه‌ی اول که کاربر مشغول ثبت ورودی‌ها بوده، حافظه‌ی چندانی مصرف نشده اما پس از آن که تابع `temp()` اجرا شده، مشاهده می‌کنیم که به مدت حدود ۵ ثانیه به صورت خطی میزان مصرف این حافظه افزایش یافته است.
<br>
برای یافتن علت این موضوع، به کد مراجعه می‌کنیم و مشاهده می‌شود که در این تابع یک حلقه وجود دارد که صرفا اعدادی را داخل یک `ArrayList` ذخیره می‌کند. از آنجایی که تعداد این اعداد بسیار زیاد است، حجمی حدود ۴ گیگابایت توسط این بخش از کد اشغال می‌شود.
<br>
این حجم به مدت زمان نسبتا زیادی اشغال می‌ماند تا زمانی که Garbage Collector فراخوانی شده و حافظه را آزاد می‌کند.
<br>
در دو نمودار بالایی سمت راست، فراخوانی‌های مربوط به گاربج کالکتور نمایش داده شده و همانطور که مشاهده می‌شود، این فراخوانی‌ها درست در همان زمانی هستند که میزان استفاده از حافظه‌ی Heap به طور قابل توجهی کاهش یافته است.
<br>
در نمودار دیگر میزان استفاده از Non-Heap Memory را مشاهده می‌کنیم که مقدار استفاده‌ی نسبتا ثابتی در طول زمان داشته است. دلیل افزایش اندک این میزان از حافظه، صدا زدن توابع مختلف و اضافه شدن Stack Frame می‌باشد.

در دو تصویر بعدی، یعنی بخش _Performance_ و _Summary_ خلاصه‌ی اطلاعات فوق نمایش داده شده است:
![Performance](./images/12%20-%20Performance.png)
![Summary](./images/13%20-%20Summary.png)

## بخش دوم
در این بخش تلاش می‌کنیم تا ابتدا یک قطعه کدی بنویسیم که زمان اجرای بالایی داشته و سپس تلاش می‌کنیم تا زمان اجرای آن و همچنین منابع مصرفی آن‌را با تغییر الگوریتم کاهش دهیم.
<br>
الگوریتم انتخاب شده، محاسبه‌ی عدد _n_ ام دنباله‌ی فیبوناتچی می‌باشد. دو الگوریتم مختلف پیاده‌سازی می‌کنیم:
```java
public static long fibRec(int n){
    if (n == 1 || n == 0){
        return 1;
    }else{
        return fibRec(n-1) + fibRec(n-2);
    }
}
```
```java
public static long fibDp(int n){
    long res = 1;
    long tmp1 = 1;
    for (int i = 1; i < n; i++){
        long tmp2 = res;
        res += tmp1;
        tmp1 = tmp2;
    }
    return res;
}
```
در الگوریتم اول، تلاش می‌کنیم تا به صورت بازگشتی جمله‌ی n ام را محاسبه کنیم اما در الگوریتم دوم، با استفاده از _Dynamic Programming_ زمان اجرا را به طور قابل توجهی کاهش می‌دهیم.
<br>
ابتدا الگوریتم اول را اجرا می‌کنیم و به عنوان ورودی به آن عدد ۵۰ را می‌دهیم. نمودار زیر، نمودار مصرف منابع مختلف توسط این برنامه می‌باشد:
![مصرف منابع در الگوریتم بازگشتی](./images/17%20-%20FibRec%20Performance.png)
همانطور که مشاهده می‌شود، این برنامه میزان مصرف نسبتا ثابتی در تمامی منابع داشته است. تنها میزان استفاده از Non-Heap Memory به طور قابل توجهی افزایش یافته که دلیل آن صدا زدن توابع بازگشتی و زیاد بودن تعداد Stack Frameهای فعال در حین اجرای برنامه می‌باشد.
<br>
در تصویر زیر، خلاصه اطلاعات مربوط به اجرا نوشته شده است:
![خلاصه اطلاعات اجرایی الگوریتم بازگشتی](./images/18%20-%20FibRec%20Summary.png)
چیزی که قصد بهبود آن‌را در الگوریتم دیگر داریم، زمان اجرا می‌باشد. زمان اجرای این برنامه حدود ۳۵ ثانیه ثبت شده است.

اکنون الگوریتم دوم، یعنی محاسبه‌ی جمله‌ی ۵۰ام دنباله فیبوناتچی با استفاده برنامه‌ریزی پویا را اجرا می‌کنیم. در تصویر زیر، خلاصه مصرف منابع این برنامه آورده شده است:
![مصرف منابع در الگوریتم برنامه‌ریزی پویا](./images/21%20-%20FibDp%20Performance.png)
همانطور که در تصویر قابل مشاهده می‌باشد، زمان اجرا بسیار پایین‌تر بوده، همچنین تعداد تردها کمتر بوده و البته میزان استفاده از حافظه‌ی Non-Heap افزایش چندانی نداشته است.
<br>
در تصویر زیر، خلاصه اطلاعات را مشاهده می‌کنیم:
![خلاصه اطلاعات اجرایی الگوریتم برنامه‌ریزی پویا](./images/22%20-%20FibDp%20Summary.png)
در اینجا می‌بینیم که کل برنامه در زمان ۲ ثانیه اجرا شده و این یعنی حدود ۱۷ برابر افزایش سرعت برای ورودی ۵۰ را شاهد بودیم.
<br>
کدهای مربوط به این بخش همگی در کلاس `/src/Fibonacci.java` قرار دارند.
